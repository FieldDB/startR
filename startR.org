#+TITLE:     Starting R
#+AUTHOR:    Scott Jackson
#+EMAIL:     
#+DATE:      October 25, 2012
#+DESCRIPTION:
#+KEYWORDS:
#+LANGUAGE:  en
#+OPTIONS:   H:3 num:t toc:t \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+LATEX_HEADER: \usepackage[margin = 1in]{geometry}
#+LATEX_HEADER: \usepackage{times}

#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LINK_UP:   
#+LINK_HOME: 
#+XSLT:

* Intro
** What?
R is:
   - a programming language
   - a platform for running code in that language, to perform statistical analysis and related functions (plotting, etc.)
   - an open-source project based on the "S" language developed at Bell Laboratories
   - a massive community of open-source contributors (over 4000 contributed packages, and growing)
   - a system that many "big names" use, at least for initial analysis (e.g., Google, New York Times)
   - cross-platform (Windows/Mac/Linux), actively developed, incredibly stable
   - not the end-all, be-all of analysis, but pretty close, at least for most people
** Why?
Benefits of R include:
  - personal empowerment
  - flexibility and power
  - access to cutting-edge stats
  - ability to produce truly beautiful output
  - ability to reproduce your analysis without having to remember every step you took
  - opens path to learning other programming languages, giving you even /more power/ (muaahahahaha!!!)
  - it's free!
Side-effects of mastering R may include:
  - insufferable superiority complex
  - the tendency to talk about how awesome R is in inappropriate situations (to friends, your significant other, at parties, etc.)
  - other people asking for your help
  - delving into dark arts of statistics that Man Was Not Meant to Know
* Installing
** Getting R
Go to [[http://www.r-project.org/]], follow the download links, and find the download appropriate for your operating system (Windows/Mac/Linux). Easy!
** Getting RStudio
As mentioned above, R is both a /programming language/ and a /platform/ for running code in that language on your computer. The basic installation you get from the site above comes with a basic "graphical user interface" (GUI), but it's extremely bare bones.  Currently, the best dedicated interface for R is [[http://www.rstudio.com/][RStudio]]. It's also free and open-source, and is constantly adding amazing features. Unless you're already invested in some other editor or environment (like Emacs, vi(m), Eclipse, etc.), I highly recommend RStudio as the way to interact with R.

To get Rstudio, just follow the link above (or google it), and download/install, following the instructions for your system. Like R, it's cross-platform.
** Getting Git
As "extra credit," consider installing Git, the version-control software.  Head on over to [[http://git-scm.com/]] and find the download links for your system.  I will not go into great depth on Git, but if you install Git, you will "unlock" some neat features in RStudio.
* Interacting with R
** First steps
So, now you've installed R, and hopefully RStudio. Now what? When does the awesomeness start? First, try just starting "vanilla" R, not RStudio.  You'll end up seeing a very boring-looking window open up, and some version info display in a very ugly font, and then this:
#+begin_example
>
#+end_example
... with a flashing cursor.  This is the /command line/. R is waiting patiently for you to give it commands.  This is often the point where many people will run screaming; this is the initial horrifying experience of "command-line paralysis," when you realize you have absolutely nothing to say to R.

Ok, so for now, run screaming, and then start RStudio instead.  RStudio gives a slightly more visually attractive scene, and you'll notice a few different windows. But there's still the "console" pane, which has that same intimidating cursor.  Time to get un-intimidated.
** Overgrown calculator
Type in the following:
#+begin_example
2 + 2
#+end_example
And hit "Enter".  You should see something like this:
#+begin_example
> 2 + 2
[1] 4
>
#+end_example
Here's what happened. You gave R a command it understood, and then it /evaluated/ it, and by default, printed the value.  I'll explain the little "\texttt{[1]}" later, but it's basically just saying "the first element of the value you asked for is...". The answer of "4" only has one element, so it's a little redundant here. That's okay.

The big point here is that you just type stuff, hit "Enter", and then R evaluates what you typed, and gives you something back. So when I said that R is a programming language, that's true, but "programs" can essentially be one little statement, and you don't have to be a "true programmer" (whatever that means) to do lots of things with R. So to reduce some of the command-line paralysis, just try out some calculations, just to get used to the process.

** Reproducible research
Data analysis is hard.  It's fun and challenging, but it's hard work. Personally, I'm lazy and forgetful. You may be much less lazy and forgetful than I am, or maybe not. But I almost guarantee that if you /pretend/ that you're lazy and/or forgetful for the purposes of data analysis, you will produce better work.  Here's why.

When I first learned how to carry out an ANOVA, I created formulas "by hand" in Excel, computed sums of squares, and so on. That process was a little laborious, but at least now I had this nice Excel spreadsheet, and I could plug new numbers into it and get new results. Imagine that instead I would have to re-enter the formulas every time I wanted to run the ANOVA on new data. That would be a pain!  This is what I mean by "lazy." If I set things up right, I should be able to run the same analysis repeatedly with no effort. That is, I should be able to make it /reproducible/.

Now imagine that I was using this spreadsheet to do these calculations, and reported some results in a paper.  Then later I realized that I wanted to do a new analysis with a different kind of correction for multiple comparisons or sphericity violations, or something like that.  And so I update my spreadsheet, or make a new version or something. Now let's say I publish some papers with these different analyses, and about 2 or 3 years after I made that initial spreadsheet, they come out in press, and someone questions my analysis, and I need to go back and remember exactly what I did.  Will I be able to find that spreadsheet?  What if I've tweaked it 10 times since then?  Will I be able to remember exactly which steps I took in the analysis?  I'm forgetful, but even people with great memories will likely struggle to recall fine-grained details of analyses they did months or years ago.

In the end, it is all too common that people will produce results or analyses that they would have a hard time reproducing themselves. This is not an ideal state of affairs for good science, since replication and reproducibility are, for some people, /necessary/ for good science.  So what can we do?  The answer is to do our best to make our work more reproducible, starting with the goal of making it easy for us to reproduce our own results, and to be able to recover all the details necessary for that reproduction, as transparently as possible.

Wait. Isn't this an R tutorial?  Why am I on this soapbox?  Here's the point: R has a variety of really marvelous tools for making your work reproducible. These can be a godsend for any of us, but especially those as lazy and forgetful as I am.

** The script interface
There are some /very/ fancy tools for reproducible research in R. I highly encourage you to explore them as your R skills sharpen.  But let's start with one of the simplest tools: the R /script/. A script is just a file that contains a bunch of commands.  So instead of typing things in one at a time in the console interface, we can store things in a script and run commands from there.

In RStudio, go to File > New script, and you should see a blank script open in one of the panes (usually the upper-left by default, but this may vary, depending on how you've arranged things for yourself).  This is just a simple text file (meaning you can read it with any text editor) with the file extension \texttt{.R}.

Now enter in some of the commands you typed earlier (the math calculations). You'll notice that nothing is evaluated when you type into the script and hit Enter. That's by design. But now go to a line with a command on it, and click the little "Run" button at the top of the pane. You can also hold down the "Control" key[fn:macctrl] and hit Enter, which has the same effect. The effect is to "send" the line to the console, and run it. The only difference is that the line does not go away, but stays right there in your script, where you can run it anytime. 

[fn:macctrl] On Macs, this is the "command" key.

Now imagine that instead of a few random math expressions in your script, you have 50 lines of commands that you carefully designed to read in your data, format it, do some manipulations or transformations, run an analysis, create some plots, and print out the analysis results in a way that you can more easily share. This is reproducible research! Two years later, you could come back to the script, and see exactly how you went from point A to point B.  Well, you could do that, as long as you can still read and understand your old code. This is the second big piece of reproducible research (the first is to use a tool that can reproduce all your old steps): when you write code, try to write it for your /future/ self.  Make things as legible and transparent as possible.  Use comments! 

What's a comment? In R, if you use the symbol =#=, anything to the /right/ of that symbol will be ignored when you run the code.  For example:

#+begin_src R :session *R* :exports code
  # This is a comment, and is totally ignored
  2 + 2
  17 * 43 # the 17 * 43 code will run, but this comment will be ignored
#+end_src

As I mentioned, there are fancy and powerful tools for reproducible research with R, which allow for more involved ways of combining code and non-code.  But comments are the simplest, and most immediately accessible way of making notes to your future selves, to make their lives easier by making your old code more comprehensible.

** Workflow summary
In summary, there are many ways to interact with R. We have just barely scratched the surface here, but two primary modes of interaction are in /interactive/ mode, and in /script/ mode. By "interactive," I mean "you type something at the command prompt in the console, and you get something back, rinse and repeat." By "script," I mean that you record commands in a script, and use the handy RStudio interface to run code from the script. In reality, having both side-by-side is extremely useful. Think of the console as your "temporary" or "messing around" work space. The process of working with data involves a lot of trying things, seeing what works, and fiddling around. Being able to "fiddle around" at the command prompt, and then "record" things that work by putting them into your script is a very useful workflow. Ultimately, you will find your own balance. But I recommend a "mixed" approach of some kind.
* Getting data into R
** Reading data
Okay, so now what? We're talking about workflow, but what can you actually /do/? So far, we've just used R as a glorified calculator.

Most people want to start by getting data into R. Let's do that. Find some data. Preferably, start with the file "exampledata.csv" that should be included in the GitHub repo here: [[github link here]].  Grabbing some other CSV (comma-delimited file) file is a good way to start, too.

Now, RESIST the urge to look for a button to click (like "Open..."). This will only slow down your understanding of how R works.  Remember that R is like a faithful servant, patiently waiting for you to make requests.  The R language is what you should use to make these requests. Anything else is a crutch that will either (a) slow you down, or (b) make your work less reproducible.  

So how do you ask R to do something? Here's where the analogy of language can help. Just like most sentences require some kind of verb, R commands all involve a /function/ of some kind. And just like verbs have /arguments/ like subject and object, functions have /arguments/ that tell R what to apply the function to.  Sometimes functions and arguments are hidden in some way (like default arguments), but they're always there.  To run a function, you just have the name of the function, followed by parentheses. In order to load data, R needs to be able to find our data.  As a first step, run this code:
#+begin_example
  dir()
#+end_example
The output lists all the files you have in the /working directory/ of R. The working directory is really just the folder where R is currently "pointing." So if you tell R to read a file or create a plot or something, it will default to that working directory folder. If you have no idea where R is currently pointing, run this command:
#+begin_example
  get.wd()
#+end_example
This prints out the path to the current working directory.

#+BEGIN_LaTeX
\ \newline
{\Huge STOP!!!}
#+END_LaTeX

#+begin_quote
You have just been exposed to two functions: =dir= and =get.wd=. This is what makes learning R hard --- remembering functions. There are many, MANY functions, but the good news is that you will quickly start to build an "active" vocabulary of just a few functions that you use very frequently. It will be hard at first, but you'll get it. What I recommend is to create a personal "cheat-sheet" that you can use for quick reference. There are many good resources all over the web for finding useful functions. However, in the moment, while you're learning, stopping to search the web for 30 minutes to find some function you need is not terribly efficient if you can avoid it. So when you add new functions to your vocabulary, it can be helpful to add them to a little mini-reference or "cheat-sheet" you can keep handy for quick look-up, to save you time.  This is another advantage of scripts: save your scripts, and you'll have examples of all the functions you end up finding and using, and these can be used to jog your memory. But just like learning a natural language, using your new "vocabulary" in accomplishing actual tasks is a far better use of your time than spending time trying to memorize lists of words/functions.

We now return to the tutorial...
#+end_quote

So now we can see where R is pointing, and we can see what's in that directory. So in order for R to be able to "see" your data, we have two options: point R to the folder where your data is, or move your data to where R is already pointing. The latter, you can do the same way you already move files around your computer.  Give it a try.

But this is not always convenient or desireable, so in order to change the working directory, you use the function =set.wd=.  Just include an argument that's the name of the folder you want to change to, surrounded by double-quotes.  If you don't know how to find the exact path name to a folder, go learn a little more about your operating system; this is a useful thing to know in general, not just for working with R. You can use this name (inside double quotes) in =set.wd= to change the working directory, and you can always use =dir= and/or =get.wd= to confirm that the change worked.

Now that R is pointing in the right direction, you need another function to actually read the data. This is a subtle but important distinction from other programs you may be used to.  In order to open a Word document using the Word program, you just double-click a Word document.  Same with SPSS files, Excel spreadsheets, and so on.  But R is a different, more flexible beast.  It can read LOTS of different data types, including Excel files, SPSS files, text documents, CSV files, HTML, etc. etc.  And while R does have its own file type that's not readable by other programs, it usually better to keep things more transparent. For example, plots saved as PDF or PNG or JPEG files are far more useful than some weird thing that only R can open. Similarly, keeping data files in simple formats like =.txt= or =.csv= makes them readable to a wide variety of programs, not just R.

Another reason that R is not a "double-click-to-open-files" kind of program is that not all data files are formatted in the same way, and R needs to be flexible in how it reads in data, so that it makes sense to the person analyzing the data. Finally, when you're working with R, you aren't messing around with files unless you tell it to write to a file. So you can read in the data from a file and do all sorts of reformatting and changes, and the base file is not changed in the least, until you tell R to write to that file. This gives you the freedom to do lots of things with your data, without worrying about "messing up" anything.

So back to the present: we are trying to read a file called "example.csv".  It's as easy as this:
#+begin_example
  my.data <- read.csv("example.csv")
#+end_example
Simple, but there are two new concepts here: /value assignment/ and /naming conventions/. But before we get to those, you may have been disappointed when you ran that line. If it gave you an error and said it couldn'd find it, check the steps above, to make sure that the file is in the working directory, and that you're not making any typos. But if it worked, it will look like nothing happened at all! Anti-climactic!  But if you do the following, you will see a sign that it worked:
#+begin_example
  ls()
#+end_example
That should print out the name "my.data", perhaps among others, if you've been playing around some.  This means that the value has been assigned, and is available in your workspace.
*** Value assignment and the workspace
When we were doing simple math, we weren't hanging on to the values, but just printing them out. But what if we wanted to /store/ the value of one of the calculations, and then use it later?  Check this out:
#+begin_example
  x <- 17 * 43
  x
  x + 5
#+end_example
The first line stores the value of 17 * 43 into an /object/ with the name "x", and then if we ask for the value of x, or do more things with the value of x, it uses that value that we stored earlier. The function we use to do this is called the "assignment" function, and is symbolized using an "arrow" kind of symbol, like this: =<-=

You can imagine the arrow showing that the value is being put "into" the variable, or something like that. In other programming languages, this operator is usually a single equal sign ("="). This also works in R, and some people use it instead of the "arrow" symbol. There is actually one subtle difference, but in terms of building good R habits, I encourage you to just get in the habit of using the "arrow" symbol for assignment everywhere.

So when we ran the code to read in our data, we assigned the value given by the =read.csv= function into an object called =my.data=. If you don't do the value assignment, R will just print out the whole contents of the file to the screen (perhaps stopping early if it's a huge file), just like R printed the results of our little math expressions to the screen. The point is that we don't /want/ the file dumped to the screen, we want the file contents to be avaiable for other things (like analysis, etc.). That is, we want the data to be in the /workspace/.

The workspace is basically all the objects that are available for analysis. Notice the distinction between the workspace and the working directory. The working directory is where R goes to look for files if you tell it to look for files (or to create files). But the workspace is "inside" R, and is all the stuff that R can directly manipulate in order to do analysis. In short, you need to get things into your workspace if you want to work with them.[fn:memorylimits]

[fn:memorylimits] The workspace is literally held in your computer memory (RAM), which is one of the limitations of R when working with truly massive data sets. It's rare nowadays to run out of space in your workspace, but it can happen, and in that case, I recommend you look around for the many developing tools for managing "Big Data" with R.

In order to put things into the workspace, you use the "arrow" (=<-=). In order to remove things from the workspace, you can use the =rm= function. In order to see what all is in your workspace, you can use the =ls= function. Additionally, RStudio has some handy interfaces with looking at what's in your workspace.

*** Naming and stylistic conventions
When we assigned the value of our data, we named the resulting object =my.data=. You may (or may not) have wondered about the period in the name. In short, R gives you a lot of flexibility in how you name your objects. We could have named it =MyVeryImportantDataSetFromTheMostAwesomeExperimentEver=. But that would be a pain to type (see above re: I'm lazy).  There are really just a couple of rules for naming objects:
1. The name needs to start with a letter.
2. The name cannot contain any special symbols or spaces (i.e., just letters and numbers).
3. Case matters (i.e., =my.data= is different from =My.data=)
Different people come up with their own styles, and Google even has a "standard" that they suggest for R, [[http://google-styleguide.googlecode.com/svn/trunk/google-r-style.html][available here at this link]]. But generally, some of the basic princples of good style are:
1. Make names as descriptive as possible, without getting too long.
2. Use one of three methods of separating words, to improve legibility:
   - camelCase :: myGreatVariableName (not mygreatvariablename)
   - dots :: my.great.variable.name
   - underscores :: my_great_variable_name
3. Avoid capital letters unless using camelCase or some other convention, because it just turns out to be really hard to remember capitalization, plus it requires extra keys to be hit (/really/ lazy...).

Most functions in R tend to use the "dots" style, so that's the style I typically use. But the point here is that it's a "style" choice, not a "rule," so it's up to you.  Just make things legible, memorable, and easily typed, and you're fine.

*** Reading data summary
To recap:
    - Reading data into R means:
      1. Getting the file into the R /working directory/, either by moving the file or changing the working directory, so that R will be able to "see" the file when you tell it to look.
      2. Using an appropriate function to read the data. We used =read.csv= here, but there are a whole host of functions to read different data types.
      3. Storing the value of the function in an /object/ (sometimes also known as a /variable/), using the assignment operator "=<-="
    - Reading data does not affect the file in any way, just makes the /values/ from the file available in the R /workspace/.
    - The workspace is the R-internal set of "active" object that R can manipulate and analyze.
    - Use a consistent and legible set of conventions when naming objects, when at all possible. This will help with legibility and reproducibility.

** Creating data

** Checking the workspace
* Inspecting data
Ok, now that 
* An intro to data munging
* A quick analysis
* Getting things out of R
* Next steps



